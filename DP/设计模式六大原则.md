# 设计模式六大原则

1. 单一职责（RSP）

   **有且仅有一个原因引起类的改变**

   难点在于：职责的划分，变化因素衡量

   优点在于：可维护性高，可读性高，抵抗变化的风险降低

   实际项目中：过分的单一职责会引起类数量骤增，增加系统复杂性，可维护性反而降低

   可适用于：接口，类，方法

2. 里氏替换原则（LSP）： **增强程序健壮性**

   简言之就是 **父类出现的地方子类也能出现**

   * 子类必须完全实现父类的方法
   * 子类可以拓展自己
   * 覆盖或者实现父类的方法时输入参数可以被放大（子类方法不会被执行）
   * 覆盖或者实现父类的方法时输出结果可以被缩小

   在LSP中子类的“个性化”会导致子类与父类关系难以调和，子类单独使用则缺少替换性，代码耦合关系错综复杂

3. 依赖倒置原则（DIP）

   3要点：

   * 高层模块不应该依赖低层模块，而是共同依赖其抽象（模块间通过依赖抽象发生关系，实现类间不直接发生依赖）
   * 抽象不应该依赖细节（抽象类或者接口不应该依赖实现类）
   * 细节应该依赖抽象（实现类依赖接口或者接口）

   **精髓：面向接口编程**

   “倒置”其实就是将依赖通过抽象或者接口发生。“正置”：则恰好相反，依赖直接通过实现类

   好处：减少类耦合，提升系统稳定性。降低并行开发风险，提高可读性可维护性

   * 每个类尽量都有接口或抽象
   * 变量的表面类型尽量时接口或抽象
   * 任何类不应该从具体类派生（不是绝对）
   * 尽量不要覆写基类的方法
   * 结合里氏替换原则

4. 接口隔离原则

   接口: 

   实力接口(Object Interface) Java中的体现就是new的对象 

   类接口(Class Interface) Java中的体现就是定义的Interface

   **原则**

   * 客户端不应该依赖他不需要的接口
   * 间的依赖应该建立在最小的接口上

   约束:

   * 保证接口尽可能小的前提下,需要满足单一职责原则,避免过度细分
   * 接口要高内聚,对外公布的接口要慎重
   * 定制服务,也就是单独对一个个体提供优良服务,而不是杂合在一起
   * 接口设计是有限度的,原则是死的,需求与经验判断实际问题

   实践:

   一个接口只服务与一个模块或者一个业务

   通过业务逻辑压缩接口中的public方法,保证接口的精炼

   被污染的接口尽量去修改,变更的风险更大的话采用适配器模式转化处理

   需求与业务逻辑,项目环境等因素的加入

5. 迪米特法则(最少知原则)

   ​

   ​

   ​

   ​