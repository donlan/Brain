# 设计模式六大原则

1. 单一职责（RSP）

   **有且仅有一个原因引起类的改变**

   难点在于：职责的划分，变化因素衡量

   优点在于：可维护性高，可读性高，抵抗变化的风险降低

   实际项目中：过分的单一职责会引起类数量骤增，增加系统复杂性，可维护性反而降低

   可适用于：接口，类，方法

2. 里氏替换原则（LSP）： **增强程序健壮性**

   简言之就是 **父类出现的地方子类也能出现**

   * 子类必须完全实现父类的方法
   * 子类可以拓展自己
   * 覆盖或者实现父类的方法时输入参数可以被放大（子类方法不会被执行）
   * 覆盖或者实现父类的方法时输出结果可以被缩小

   在LSP中子类的“个性化”会导致子类与父类关系难以调和，子类单独使用则缺少替换性，代码耦合关系错综复杂

3. 依赖倒置原则（DIP）

   3要点：

   * 高层模块不应该依赖低层模块，而是共同依赖其抽象（模块间通过依赖抽象发生关系，实现类间不直接发生依赖）
   * 抽象不应该依赖细节（抽象类或者接口不应该依赖实现类）
   * 细节应该依赖抽象（实现类依赖接口或者接口）

   **精髓：面向接口编程**

   “倒置”其实就是将依赖通过抽象或者接口发生。“正置”：则恰好相反，依赖直接通过实现类

   好处：减少类耦合，提升系统稳定性。降低并行开发风险，提高可读性可维护性

   * 每个类尽量都有接口或抽象
   * 变量的表面类型尽量时接口或抽象
   * 任何类不应该从具体类派生（不是绝对）
   * 尽量不要覆写基类的方法
   * 结合里氏替换原则

4. 接口隔离原则

   接口: 

   实力接口(Object Interface) Java中的体现就是new的对象 

   类接口(Class Interface) Java中的体现就是定义的Interface

   **原则**

   * 客户端不应该依赖他不需要的接口
   * 间的依赖应该建立在最小的接口上

   约束:

   * 保证接口尽可能小的前提下,需要满足单一职责原则,避免过度细分
   * 接口要高内聚,对外公布的接口要慎重
   * 定制服务,也就是单独对一个个体提供优良服务,而不是杂合在一起
   * 接口设计是有限度的,原则是死的,需求与经验判断实际问题

   实践:

   1. 一个接口只服务与一个模块或者一个业务
   2. 通过业务逻辑压缩接口中的public方法,保证接口的精炼
   3. 被污染的接口尽量去修改,变更的风险更大的话采用适配器模式转化处理
   4. 需求与业务逻辑,项目环境等因素的加入

5. 迪米特法则(最少知原则)

   - 也就是说一个对象对其他对象有最少的了解，因为一个对象对其他对象有越多了解，相互间的耦合就会更大。
   - 即使是有相互关系的对象之间也应当保持适当的距离，就是说当一个类依赖另一个类的时候，并不需知道另一个类里的所有方法，如果需要依赖一个类里的多个方法，可以尽可能封装到一个只对外产生依赖的方法中。
   - 一个角度说，就是尽可能的保持内敛，对外公布更少的内容。

   当一个方法即可以放在本类中，也能放在其他类中的时候，都放在本类中。

   但是实际项目中可能存在很复杂的业务逻辑，那么死守迪米特法则则，那么必然会增加很多中间类，这反而增加了维护难度。

6. 开闭原则

   **对拓展开放，对修改关闭**（软件实体应该通过拓展实现变化，而不是修改实体代码）

   软件实体：

   - 软件中的一个模块
   - 抽象和类
   - 方法

   这里说的对修改关闭，并不是说不能做任何修改，因为底层的模块变化必然有高层模块进行耦合。除非模块是没有任何联系，那样就没有意义了。

   变化的三种类型：

   1. 逻辑变化

      一般在原有的类中进行修改即可

   2. 子模块变化

      一个模块的变化会对其他的模块产生影响，适合通过拓展进行适应变化

   3. 可见视图变化

      也就是展示给用户的内容，这个可大可小，具体设计到逻辑变化的时候就需要做出更多的修改。

   重要性：

   1. 对于测试的影响

      通过修改的方式响应变化，处理需要重新编写测试用例外，还需要整个代码的回笼一般，然后进行各种测试，无疑增加了工作量。

   2. 提高复用性

      缩小逻辑，越小的逻辑越能被复用，也就是对修改关闭的，我只负责这一个操作。

   3. 提高可维护性

      拓展比修改更容易，尤其是代码之前不是你写的。

   4. 面向对象开发的要求

   使用开闭原则

   1. 抽象约束

      - 通过接口或者抽象类实现对拓展的边界约束，不允许出现在接口或者抽象类中不存在的公开方法
      - 参数类型，引用对象尽量使用抽象类或者接口
      - 让抽象层保持稳定

   2. 尽量使用元数据控制程序行为

      例如Spring框架通过子类继承，然后修改配置文件就可以实现变化。

   3. 指定项目章程，团队约定

   4. 封装变化

      将相同的变化封装到一个接口或者抽象类中，将不同的变化封装到不同的接口或者抽象类中。尽可能预知变化，封装变化。

   ​

   ​

   ​

   ​

   ​

   ​